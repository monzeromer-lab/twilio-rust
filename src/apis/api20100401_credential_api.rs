/*
 * Twilio - Api
 *
 * This is the public Twilio REST API.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@twilio.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};

/// struct for passing parameters to the method [`create_sip_credential`]
#[derive(Clone, Debug)]
pub struct CreateSipCredentialParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The unique id that identifies the credential list to include the created credential.
    pub credential_list_sid: String,
    /// The username that will be passed when authenticating SIP requests. The username should be sent in response to Twilio's challenge of the initial INVITE. It can be up to 32 characters long.
    pub username: String,
    /// The password that the username will use when authenticating SIP requests. The password must be a minimum of 12 characters, contain at least 1 digit, and have mixed case. (eg `IWasAtSignal2018`)
    pub password: String
}

/// struct for passing parameters to the method [`delete_sip_credential`]
#[derive(Clone, Debug)]
pub struct DeleteSipCredentialParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The unique id that identifies the credential list that contains the desired credentials.
    pub credential_list_sid: String,
    /// The unique id that identifies the resource to delete.
    pub sid: String
}

/// struct for passing parameters to the method [`fetch_sip_credential`]
#[derive(Clone, Debug)]
pub struct FetchSipCredentialParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The unique id that identifies the credential list that contains the desired credential.
    pub credential_list_sid: String,
    /// The unique id that identifies the resource to fetch.
    pub sid: String
}

/// struct for passing parameters to the method [`list_sip_credential`]
#[derive(Clone, Debug)]
pub struct ListSipCredentialParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The unique id that identifies the credential list that contains the desired credentials.
    pub credential_list_sid: String,
    /// How many resources to return in each list page. The default is 50, and the maximum is 1000.
    pub page_size: Option<i64>,
    /// The page index. This value is simply for client state.
    pub page: Option<i32>,
    /// The page token. This is provided by the API.
    pub page_token: Option<String>
}

/// struct for passing parameters to the method [`update_sip_credential`]
#[derive(Clone, Debug)]
pub struct UpdateSipCredentialParams {
    /// The unique id of the Account that is responsible for this resource.
    pub account_sid: String,
    /// The unique id that identifies the credential list that includes this credential.
    pub credential_list_sid: String,
    /// The unique id that identifies the resource to update.
    pub sid: String,
    /// The password that the username will use when authenticating SIP requests. The password must be a minimum of 12 characters, contain at least 1 digit, and have mixed case. (eg `IWasAtSignal2018`)
    pub password: Option<String>
}


/// struct for typed errors of method [`create_sip_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSipCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_sip_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSipCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`fetch_sip_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum FetchSipCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_sip_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListSipCredentialError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_sip_credential`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateSipCredentialError {
    UnknownValue(serde_json::Value),
}


/// Create a new credential resource.
pub async fn create_sip_credential(configuration: &configuration::Configuration, params: CreateSipCredentialParams) -> Result<models::ApiV2010AccountSipSipCredentialListSipCredential, Error<CreateSipCredentialError>> {

    let uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json", configuration.base_path, AccountSid=crate::apis::urlencode(params.account_sid), CredentialListSid=crate::apis::urlencode(params.credential_list_sid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    multipart_form_params.insert("Username", params.username.to_string());
    multipart_form_params.insert("Password", params.password.to_string());
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV2010AccountSipSipCredentialListSipCredential`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV2010AccountSipSipCredentialListSipCredential`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSipCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Delete a credential resource.
pub async fn delete_sip_credential(configuration: &configuration::Configuration, params: DeleteSipCredentialParams) -> Result<(), Error<DeleteSipCredentialError>> {

    let uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json", configuration.base_path, AccountSid=crate::apis::urlencode(params.account_sid), CredentialListSid=crate::apis::urlencode(params.credential_list_sid), Sid=crate::apis::urlencode(params.sid));
    let mut req_builder = configuration.client.request(reqwest::Method::DELETE, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(())
    } else {
        let content = resp.text().await?;
        let entity: Option<DeleteSipCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Fetch a single credential.
pub async fn fetch_sip_credential(configuration: &configuration::Configuration, params: FetchSipCredentialParams) -> Result<models::ApiV2010AccountSipSipCredentialListSipCredential, Error<FetchSipCredentialError>> {

    let uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json", configuration.base_path, AccountSid=crate::apis::urlencode(params.account_sid), CredentialListSid=crate::apis::urlencode(params.credential_list_sid), Sid=crate::apis::urlencode(params.sid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV2010AccountSipSipCredentialListSipCredential`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV2010AccountSipSipCredentialListSipCredential`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<FetchSipCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a list of credentials.
pub async fn list_sip_credential(configuration: &configuration::Configuration, params: ListSipCredentialParams) -> Result<models::ListSipCredentialResponse, Error<ListSipCredentialError>> {

    let uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials.json", configuration.base_path, AccountSid=crate::apis::urlencode(params.account_sid), CredentialListSid=crate::apis::urlencode(params.credential_list_sid));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = params.page_size {
        req_builder = req_builder.query(&[("PageSize", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page {
        req_builder = req_builder.query(&[("Page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = params.page_token {
        req_builder = req_builder.query(&[("PageToken", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListSipCredentialResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListSipCredentialResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListSipCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update a credential resource.
pub async fn update_sip_credential(configuration: &configuration::Configuration, params: UpdateSipCredentialParams) -> Result<models::ApiV2010AccountSipSipCredentialListSipCredential, Error<UpdateSipCredentialError>> {

    let uri_str = format!("{}/2010-04-01/Accounts/{AccountSid}/SIP/CredentialLists/{CredentialListSid}/Credentials/{Sid}.json", configuration.base_path, AccountSid=crate::apis::urlencode(params.account_sid), CredentialListSid=crate::apis::urlencode(params.credential_list_sid), Sid=crate::apis::urlencode(params.sid));
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref auth_conf) = configuration.basic_auth {
        req_builder = req_builder.basic_auth(auth_conf.0.to_owned(), auth_conf.1.to_owned());
    };
    let mut multipart_form_params = std::collections::HashMap::new();
    if let Some(param_value) = params.password {
        multipart_form_params.insert("Password", param_value.to_string());
    }
    req_builder = req_builder.form(&multipart_form_params);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ApiV2010AccountSipSipCredentialListSipCredential`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ApiV2010AccountSipSipCredentialListSipCredential`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateSipCredentialError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

